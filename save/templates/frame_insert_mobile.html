{% set buildUrlSuffix = ( '?build=' + metadata.build ) if metadata.build is defined else '' %}
<!DOCTYPE html>
<html>

<head>
  <script>
    wbinfo = {}
    wbinfo.prefix = "{{ wb_prefix }}";
    wbinfo.capture_url = "{{ url|safe }}";
    wbinfo.timestamp = "{{ wb_url.timestamp }}";
    ts = "{{ wb_url.timestamp }}"; //TODO:: maybe in the future remove this variable and use only the above
    wbinfo.is_frame = true;
    wbinfo.frame_mod = "{{ options.frame_mod }}";
    wbinfo.replay_mod = "{{ options.replay_mod }}";
  </script>

  <title>SavePageNow by Arquivo.pt</title>

  <script src="{{ static_prefix }}/wb_frame.js"></script>

  <script>
    var cframe = new ContentFrame({
      "url": wbinfo.capture_url + window.location.hash,
      "prefix": "{{ wb_prefix }}",
      "request_ts": "{{ wb_url.timestamp }}",
      "iframe": "#replay_iframe"
    });

    // add event listener thar receive messages from url search iframe.
    if (window.addEventListener) {
      window.addEventListener("message", onMessage, false);
    } else if (window.attachEvent) {
      window.attachEvent("onmessage", onMessage, false);
    }
    // generic function that receive multiple messages from url search iframe and calls different king on functions.
    function onMessage(event) {
      // Check sender origin to be trusted
      if (!event.isTrusted) return;
      var data = event.data;

      if (typeof data.wb_type !== 'undefined') {
        if (data.wb_type == "load" || data.wb_type == "replace-url" || data.wb_type == "unload") {
          ARQUIVO.updateInfo(data.url, data.ts);
        }
      } else {
        if (data.func == 'urlSearchClickOnVersion') {
          ARQUIVO.urlSearchClickOnVersion(data.message);
        }
      }
    }


    // adding an 'unload' event message to be able to quickly react to changes in context.
    // The 'unload' event message follows wb messages format.
    const iframe = document.getElementById('replay_iframe');
    function unloadHandler(e) {
      // Timeout needed because the URL changes immediately after
      // the `unload` event is dispatched.
      setTimeout(function () {
        let splitUrl = iframe.contentWindow.location.href.split('mp_/');
        if (splitUrl.length < 2) {
          return;
        }
        let message = {
          url: splitUrl.filter((x, i) => { return i > 0 }).join('mp_/'),
          ts: splitUrl[0].split('/').pop(),
          wb_type: 'unload'
        };
        window.postMessage(message);
      }, 0);
    };
    function attachUnload() {
      // Remove the unloadHandler in case it was already attached.
      // Otherwise, the change will be dispatched twice.
      iframe.contentWindow.removeEventListener("unload", unloadHandler);
      iframe.contentWindow.addEventListener("unload", unloadHandler);
    }
    iframe.addEventListener("load", attachUnload);
  </script>
</head>

<body style="margin: 0px; padding: 0px;">

  <div id="wb_iframe_div">
    <iframe name="replay_iframe" id="replay_iframe" src="{{ wb_prefix + embed_url }}" seamless="seamless"
      frameborder="0" scrolling="yes" class="wb_iframe noprint" target="_parent">
    </iframe>

  </div>
</body>

</html>