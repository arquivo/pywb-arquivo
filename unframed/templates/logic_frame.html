<!DOCTYPE html>
<html>
<!--   This frame is meant to give context-change information to the parent IFF 
     this page is being loaded in an iframe. Otherwise, the frame should look 
     and behave as if it wasn't there. -->
<!--   Implementing this frame allows the front-end code to be completely 
     separated from the pywb code, only having to be mindful of the messages 
     that the iframe sends it. -->
<!--   Pywb also recommends using a frame for security reasons, see more at
     https://pywb.readthedocs.io/en/latest/manual/configuring.html?highlight=framed_replay#framed-vs-frameless-replay -->
<!--   Messages sent by this frame are the messages generated by wombat, see
     more at https://github.com/webrecorder/wombat. There's an additional 
     (non-standard) message implemented that warns the parent as soon as a new 
     page starts being loaded. This message follows the wombat message structure
     and uses wb_type 'unload' (unused by wombat). It also sends the following
     information:
       url - URL for the new page being replayed 
       ts - timestamp for the new page being replayed
     The purpose of this message is to allow the parent to change its context 
     while the page is still loading, providing a better user experience. -->
<head>
  <title>Arquivo.pt</title>
  <script src="{{ static_prefix }}/wb_frame.js"></script>
</head>

<body style="margin: 0px; padding: 0px;">

  <div id="wb_iframe_div" style="position:absolute;top:0px;left:0px;width:100%;height:100%;">

    <iframe name="replay_iframe" id="replay_iframe" style="overflow:hidden;height:100%;width:100%;border:0px;">

    </iframe>
  </div>
  <script>
    var cframe = new ContentFrame({
      "url": "{{ url }}" + window.location.hash,
      "prefix": "{{ wb_prefix }}",
      "request_ts": "{{ wb_url.timestamp }}",
      "iframe": "#replay_iframe"
    });
    
    // Relay messages to parent if in an iframe:
    if (window.parent != window) {
      // Damn it internet explorer...
      let eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
      let messageEvent = eventMethod == "attachEvent" ? "onmessage" : "message";

      window[eventMethod](messageEvent, (e) => { 
        let key = e.message ? "message" : "data";
        // Only relay messages from pywb
        if(e[key] && e[key].wb_type) {
          window.parent.postMessage(e[key],"*");
        }
      }, true);
      
      // adding an 'unload' event message to be able to quickly react to changes in context.
      // The 'unload' event message follows wb messages format.
      const iframe = document.getElementById('replay_iframe');
      function unloadHandler(e) {
        // Timeout needed because the URL changes immediately after
        // the `unload` event is dispatched.
        setTimeout(function () {
          let splitUrl = iframe.contentWindow.location.href.split('mp_/');
          if (splitUrl.length < 2) {
            return;
          }
          let message = {
            url: splitUrl.filter((x, i) => { return i > 0 }).join('mp_/'),
            ts: splitUrl[0].split('/').pop(),
            wb_type: 'unload'
          };
          window.postMessage(message);
        }, 0);
      };
      function attachUnload() {
        // Remove the unloadHandler in case it was already attached.
        // Otherwise, the change will be dispatched twice.
        iframe.contentWindow.removeEventListener("unload", unloadHandler);
        iframe.contentWindow.addEventListener("unload", unloadHandler);
      }
      iframe.addEventListener("load", attachUnload);

    }
  </script>

</body>

</html>